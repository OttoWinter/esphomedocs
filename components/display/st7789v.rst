ST7789V TFT LCD
===============

.. seo::
    :description: Instructions for setting up ST7789V TFT LCD display drivers.
    :image: st7789v-full.jpg

.. _st7789v:

Usage
-----

The ``st7789v`` display platform allows you to use
ST7789V (`datasheet <https://github.com/Xinyuan-LilyGO/TTGO-T-Display>`__,
`Tindie <https://www.tindie.com/products/ttgo/lilygor-ttgo-t-display/>`__)
displays with ESPHome. Note that this component utilizes the 4-Wire :ref:`SPI bus <spi>`; the physical
connection is already in place on the TTGO T-Display module as shown below.

.. figure:: images/st7789v-full.jpg
    :align: center
    :width: 75.0%

    ST7789V TFT LCD on TTGO T-Display module

This module has a USB-C connector with an on-board serial adapter for programming. Simply connect to a
USB-C port to get started! (Depending on your operating system of choice, you might need to install an
appropriate driver.) It is also possible to power the module via the 5V and G (ground) pins along
the edges of the module, or via a battery attached to the connector on the bottom of the board. The
ESP32's UART pins are not brought out to the headers, so the on-board serial adapter must be used for
hardwired programming. (OTA updates are of course possible after ESPHome is initially installed.)

.. code-block:: yaml

    # Example minimal configuration entry
    spi:
      clk_pin: GPIO18
      mosi_pin: GPIO19

    display:
      - platform: st7789v
        backlight_pin: GPIO4
        cs_pin: GPIO5
        dc_pin: GPIO16
        reset_pin: GPIO23
        lambda: |-
          it.print(0, 0, id(font), "Hello World!");

.. warning::

    When using the TTGO T-Display module, the GPIO pin numbers above *cannot be changed* as they are
    hardwired within the module/PCB.

Configuration variables
***********************

- **backlight_pin** (:ref:`Pin Schema <config-pin_schema>`): The display's backlight pin.
- **cs_pin** (:ref:`Pin Schema <config-pin_schema>`): The CS pin.
- **dc_pin** (:ref:`Pin Schema <config-pin_schema>`): The DC pin.
- **reset_pin** (:ref:`Pin Schema <config-pin_schema>`): The RESET pin.
- **lambda** (*Optional*, :ref:`lambda <config-lambda>`): The lambda to use for rendering the content on the display.
  See :ref:`display-engine` for more information.
- **update_interval** (*Optional*, :ref:`config-time`): The interval to re-draw the screen. Defaults to ``5s``.
- **pages** (*Optional*, list): Show pages instead of a single lambda. See :ref:`display-pages`.
- **id** (*Optional*, :ref:`config-id`): Manually specify the ID used for code generation.

Configuration examples
**********************

At the time this documentation was written, ESPHome does not offically support color displays.
*However*, with a little clever YAML and compiler magic, it is possible to utilize the color
capabilities of this display module. To do so, add a ``substitutions:`` section to your YAML to
define some colors, then bring them into the function calls in your lambada. Some examples follow:

.. code-block:: yaml

    substitutions:
      RED: '(0x1F << 11)'
      GREEN: '(0x3F << 5)'
      BLUE: '(0x1F << 0)'
      YELLOW: '(0x1F << 11) | (0x3F << 5)'
      CYAN: '(0x3F << 5) | (0x1F << 0)'
      MAGENTA: '(0x1F << 11) | (0x1F << 0)'
      WHITE: '(0x1F << 11) | (0x3F << 5) | (0x1F << 0)'
      GRAY: '(0x10 << 11) | (0x20 << 5) | (0x10 << 0)'

    ...

    display:
      - platform: st7789v
        backlight_pin: GPIO4
        cs_pin: GPIO5
        dc_pin: GPIO16
        reset_pin: GPIO23
        rotation: 90
        lambda: |-
          it.rectangle(0,  0, it.get_width(), it.get_height(), ${BLUE});
          it.rectangle(0, 20, it.get_width(), it.get_height(), ${BLUE});   // header bar

          it.strftime((240 / 2), (140 / 3) * 1 + 5, id(helvetica_24), ${GRAY}, TextAlign::CENTER, "%Y-%m-%d", id(esptime).now());
          it.strftime((240 / 2), (140 / 3) * 2 + 5, id(helvetica_48), ${GRAY}, TextAlign::CENTER, "%H:%M:%S", id(esptime).now());
          it.print(5, 5, id(helvetica_12), ${YELLOW}, TextAlign::TOP_LEFT, "ESPHome");

          if (id(system_status).state) {
            it.print(235, 5, id(helvetica_12), ${GREEN}, TextAlign::TOP_RIGHT, "Online");
          }
          else {
            it.print(235, 5, id(helvetica_12), ${RED}, TextAlign::TOP_RIGHT, "Offline");
          }

To bring in color images:

.. code-block:: yaml

    image:
      - file: "image.jpg"
        id: my_image
        resize: 200x200
        type: RGB565

    ...

    display:
      - platform: st7789v
        backlight_pin: GPIO4
        cs_pin: GPIO5
        dc_pin: GPIO16
        reset_pin: GPIO23
        rotation: 270
        lambda: |-
          it.image(0, 0, id(my_image));

Note that ``rotation:`` allows rotating of the entire display by 90, 180, or 270 degrees.

Complete example
****************

The following is a complete example YAML configuration that does a few things beyond the usual
Wi-Fi, API, and OTA configuration. It defines:

- three fonts (well, one font in three sizes)
- a ``binary_sensor`` that indicates the state of connectivity to the API
- a ``binary_sensor`` for each of the two buttons on the TTGO module
- a ``switch``, allowing control of the backlight from HA
- several colors which are applied via substitutions
- a color image to be shown on the display
- time, for display...on the display
- the SPI configuration for communicating with the display
- the display component itself, for use on the TTGO module
- a lambada which paints the screen as shown in the picture above:

  - blue borders, with a sort of "title bar" along the top
  - "ESPHome" in yellow in the top left corner
  - the API connection status, "Online" in green when connected, "Offline" in red when not
  - the time and date, more or less in the center of the display

To use this example, you need only to provide the font file, "Helvetica.ttf" (or update it to
a font of your choosing) and an image file, "image.png" (it may also be a ".jpg"). Place these
into the same directory as the YAML configuration file itself. Comment/Uncomment/Modify the
appropriate lines of C code in the lambada to hide or show the image or text as you wish.

.. code-block:: yaml

    esphome:
      name: esp_tdisplay
      platform: ESP32
      board: featheresp32

    wifi:
      ssid: "ssid"
      password: "password"

      # Enable fallback hotspot (captive portal) in case wifi connection fails
      ap:
        ssid: "esp_tdisplay"
        password: "some_password"

    captive_portal:

    # Enable logging
    logger:

    # Enable Home Assistant API
    api:
      password: "some_api_password"

    ota:
      password: "some_ota_password"

    font:
      - file: "Helvetica.ttf"
        id: helvetica_48
        size: 48
      - file: "Helvetica.ttf"
        id: helvetica_24
        size: 24
      - file: "Helvetica.ttf"
        id: helvetica_12
        size: 12

    binary_sensor:
      - platform: status
        name: "Node Status"
        id: system_status
      - platform: gpio
        pin:
          number: GPIO0
          inverted: true
        name: "T-Display Button Input 0"
        id: tdisplay_button_input_0
      - platform: gpio
        pin:
          number: GPIO35
          inverted: true
        name: "T-Display Button Input 1"
        id: tdisplay_button_input_1

    # We can still control the backlight independently
    switch:
      - platform: gpio
        pin: GPIO4
        name: "Backlight"
        id: backlight

    substitutions:
      RED: '(0x1F << 11)'
      GREEN: '(0x3F << 5)'
      BLUE: '(0x1F << 0)'
      YELLOW: '(0x1F << 11) | (0x3F << 5)'
      CYAN: '(0x3F << 5) | (0x1F << 0)'
      MAGENTA: '(0x1F << 11) | (0x1F << 0)'
      WHITE: '(0x1F << 11) | (0x3F << 5) | (0x1F << 0)'
      GRAY: '(0x10 << 11) | (0x20 << 5) | (0x10 << 0)'

    image:
      - file: "image.png"
        id: my_image
        resize: 200x200
        type: RGB565

    time:
      - platform: homeassistant
        id: esptime

    spi:
      clk_pin: GPIO18
      mosi_pin: GPIO19

    display:
      - platform: st7789v
        backlight_pin: GPIO4
        cs_pin: GPIO5
        dc_pin: GPIO16
        reset_pin: GPIO23
        rotation: 270
        lambda: |-
          it.rectangle(0,  0, it.get_width(), it.get_height(), ${BLUE});
          it.rectangle(0, 20, it.get_width(), it.get_height(), ${BLUE});   // header bar

          it.strftime((240 / 2), (140 / 3) * 1 + 5, id(helvetica_24), ${GRAY}, TextAlign::CENTER, "%Y-%m-%d", id(esptime).now());
          it.strftime((240 / 2), (140 / 3) * 2 + 5, id(helvetica_48), ${GRAY}, TextAlign::CENTER, "%H:%M:%S", id(esptime).now());
          it.print(5, 5, id(helvetica_12), ${YELLOW}, TextAlign::TOP_LEFT, "ESPHome");

          // Comment out the above lines to see the image without text overlaid
          // it.image(0, 0, id(my_image));
          
          if (id(system_status).state) {
            it.print(235, 5, id(helvetica_12), ${GREEN}, TextAlign::TOP_RIGHT, "Online");
          }
          else {
            it.print(235, 5, id(helvetica_12), ${RED}, TextAlign::TOP_RIGHT, "Offline");
          }


More About Color
****************

You might be wondering, "How exactly do I define the colors? What's going on with that?"

If you're reasonably experienced with C and/or C++ and are comfortable with boolean
and bitwise/bit-shift operators, a glance at the first nifty ASCII diagram a few paragraphs
down will probably tell you all you need to know. If you're less experienced and/or are just
plain curious, please read on.

This display has three different color modes (in other words, methods for describing the color
of the pixels); we are using the 65K "5-6-5" color mode, which is the "middle" of the three
options it offers, allowing us to describe 65,536 colors for any given pixel. In this mode,
we get five bits to describe the intensity of the red component of each pixel, five bits to
describe the intensity of blue, and six bits to describe the intensity of green. 5 + 6 + 5
conveniently adds up to 16, which happens to be the number of bits in two bytes (also known
as a "word").

Now take a deep breath, that was the easy part. This next part gets a little...tricky.

With five bits, there are 32 possible combinations of ones and zeros. This means that there
are 32 possible intensities for the red and blue components of each pixel, 0 through 31.
With six bits, there are 64 possible combinations of ones and zeros, which means we can
describe any value from 0 through 63 -- therefore, green has 64 possible intensities.
(All of this is because math.)

We have to cram all of this information--the intensity values for each of the three components,
red, green, and blue--into 16 bits, or two bytes. The display developer has formulated a
specific way to accomplish this, using a common practice where they define, within the 16-bit
range we have to work with, specific bits for each of the specific color components
(red, green, and blue). ASCII diagram time!

.. code-block:: text

    Bit Number: 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
      Controls:  R  R  R  R  R  G  G  G  G  G  G  B  B  B  B  B
           Red:  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0
         Green:  0  0  0  0  0  1  1  1  1  1  1  0  0  0  0  0
          Blue:  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1

A picture is worth a thousand...pixels? Maybe this is slowly starting to make some sense?

Great. Let's move along, and talk about what ``<<`` does and how it fits in.

Take another look at that wonderful ASCII diagram above -- specifically at one of the lower
three rows that illustrate what bits are on/off for a given component, red, green, or blue.
Now imagine "rotating" the bits, such that they each move one "click" to the right...or left:

.. code-block:: text

    Green (before):  0  0  0  0  0  1  1  1  1  1  1  0  0  0  0  0
    Green (after):   0  0  0  0  1  1  1  1  1  1  0  0  0  0  0  0

See what happened there? The bits moved! They moved to the left. A "new" bit was added on the
right-most side -- this new bit is always a zero...because that's just how it is. If we consider
what impact this has when we send this to the display, one of the "red" bits is now a one -- so
there will be a touch of red in this pixel! ...but it also lost a green bit, which means a
little bit less of green. (The pixel would begin to take on a yellow tint but still be
predominantly green, although that's not important right now.)

When we do this in our ``substitutions:`` section:

.. code-block:: yaml

    substitutions:
      RED: '(0x1F << 11)'

...what we are doing is defining a value (in this case 0x1F hexadecimal, or 31 in decimal) and
then shifting it over by 11 bits. Take a look at the awesome ASCII diagrams above again. What
happens if we put five ones in the "blue" bits but then bump them to the left eleven times?...

...

...They turn red! Moving those bits to the left by eleven places bumps them over so that they
line up with the "red" bits that we send to the display. This lights up the red element of the
pixel this is written to...and, depending on what other bits go with it, possibly some of the
other colors, too.

The last point we need to consider is that, within a given group of bits (the red bits, the
green bits, or the blue bits), the bits to the left carry a greater weight (or, really,
intensity) then the bits to the right. In other words, considering the phenomenal ASCII
diagram above, if we put a one into bit four's position, that will yield a brighter blue
than if we put a one into bit zero's position. We can mix-and-match these, which is how
we are able to achieve 32 different intensities for red and blue, and 64 for green.

Let's put it all together.

.. code-block:: yaml

    substitutions:
      WHITE: '(0x1F << 11) | (0x3F << 5) | (0x1F << 0)'

To make a pixel appear white, we need all three of the color components, red, green, and
blue, at their maximum possible intensities. What we've done with the line above is just
that. We define a five-bit value--0x1F = 31 decimal or 11111 in binary--and then shift it
left eleven bits into the "red" positions. Then we define a six-bit value of 0x3F (63 decimal
or 111111 in binary) and bump it five bits to the left, over into the "green" bit range.
Finally, we define another five-bit value, 0x1F, just as we did for red, but we don't have
to move these bits because they naturally land in the "blue" bit positions. Finally, the
``|`` character is a mathematical operator that tells the compiler to perform a logical
``OR`` between them all, which combines them into a single 16-bit value which will be passed
to whatever function we call in the lambada and, ultimately, to the display module itself.

That all said, it *is* possible to just write a single value to define the color; that is,
we *could* just do this:

.. code-block:: yaml

    substitutions:
      CYAN: 0x07FF

...but it becomes a lot more difficult when you want to make that a "darker cyan". What bits
will you change? What will the new values be? What if someone else wants to change it?
Let the fancy computer figure it out! It bumps up the character count, but using the ``<<``
and ``|`` operators will allow you to make changes later on much more quickly.

One more thing! It's also possible to use human-friendly decimal numbers all the way through:

.. code-block:: yaml

    substitutions:
      PINK: '(30 << 11) | (35 << 5) | (20 << 0)'

Do what works best for you!

If you made it this far...thanks for sticking around! Hopefully this is enough information to
help you get started defining your own sets of colors with this component. Happy hacking!

See Also
--------

- :doc:`index`
- :apiref:`st7789v_base/st7789v_base.h`
- :ghedit:`Edit`
